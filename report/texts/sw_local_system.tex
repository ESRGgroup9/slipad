%**********************************************************
%\subsection{Task Overview}
One can define and describe briefly how the local system is implemented, making use of threads and processes. As one can see in figure \ref{fig:task_overview}, this system is composed by two processes: the main process and a daemon, \textit{dSensors}, used to read synchronously the sensors \textit{LDR} and \textit{LampFailureDetector}. As the \textit{PIR} sensor can be read through the use of an ISR, asynchronously, this sensor stays in the main process. The communication between the daemon and the main process is done via message queue.

\begin{figure}[H]
	\centering
	\includegraphics[width=.3\textwidth]{09sw_specification/LS/overview}
	\caption{Inter-process Communication between Main Process and Daemon.}
	\label{fig:task_overview}
\end{figure}

%**********************************************************
\subsection{Class Diagram}
In figure \ref{fig:classDiag} is represented the class diagram of the local system. The class \textit{CLocalSystem} is the main class of the system, that initializes the objects of each class listed below.

\begin{itemize}
	\item \textbf{CLoraComm:} manages the LoRa communications, interfacing with the LoRa module;
	\item \textbf{CLamp:} manages the lamp brightness, using a PWM channel;	
	\item \textbf{CPir:} manages the motion detection sensor, PIR;
%	\item \textbf{CLdr:} manages the ambient light sensor, LDR;
%	\item \textbf{CFailureDetector:} manages the failure detetor sensor;
	\item \textbf{CCamera:} manages the camera device;
	\item \textbf{CParkDetection:} responsible of image processing for detecting parking spots.
\end{itemize}

\begin{figure}[H]
	\centering
	\includegraphics[width=1\textwidth]{09sw_specification/LS/clocalsystem/class}
	\caption{Local System Classes Diagram.}
	\label{fig:classDiag}
\end{figure}

%*****************************
\clearpage
\myparagraph{Class CLoraComm}

In figure \ref{fig:LoraCommClass} is shown the \textit{CLoraComm} class diagram. This class defines an object \textit{LoraComm}, with the address \textit{local\_addr}, capable of establishing a LoRa communication at a defined frequency \textit{freqMHz}, with the gateway, with the address \textit{dest\_addr}. This class inherits several methods from the class \textit{CCommunication}, represented with a lighter font and identified with '\^{}' at the begin of the method.

\begin{figure}[H]
	\centering
	\includegraphics[width=.4\textwidth]{09sw_specification/LS/cloracomm/class}
	\caption{Class Diagram: CLoraComm.}
	\label{fig:LoraCommClass}
\end{figure}

%*****************************
\clearpage
\myparagraph{Class CCommunication}

In figure \ref{fig:CCommunicationClass} is shown the \textit{CCommunication} class diagram. This class implements the structure for a communication class like \textit{CLoraComm} or \textit{CTCPclient}, which will be shown later. It implements a series of methods to send and receive messages. 

Makes use of a thread, \textit{tSend}, to send messages in non-blocking mode. This thread is created with \textit{init(tprio)} method, which defines the thread priority. After creation, the thread goes to sleep, and is waken whenever the condition variable \textit{condtSend} is notified, which occurs when \textit{push(msg)} is used. This function adds the given message to a buffer, \textit{TxMsgs}, which is later sent in \textit{tSend}. \textit{send(msg)} method sends a message in blocking mode; \textit{recv()} receives a message in non-blocking mode. %It's used a vector of strings \textit{tx\_msgs} to store messages, providing a waiting list of messages to be sent, in order to avoid the loss of a communication.

This class has two pure virtual functions: \textit{recvFunc} and \textit{sendFunc}, which must be defined by the derived classes, since each communication protocol has its own functions to send and receive messages. Each communication has a state, \textit{status}, defined by the enumeration connection status, \textit{ConnStatus}.

\begin{figure}[H]
	\centering
	\includegraphics[width=.64\textwidth]{09sw_specification/LS/ccommunication/class}
	\caption{Class Diagram: CCommunication.}
	\label{fig:CCommunicationClass}
\end{figure}

%*****************************
\clearpage
\myparagraph{Class CLamp}

In figure \ref{fig:classlamp} is shown the Lamp class diagram, which defines a Lamp object. After creating the object, using the constructor \textit{Lamp()}, one can interact with it by changing the brightness, through the method \textit{setBrightness(lux)}, where \textit{lux} is a value from 0, lamp OFF, to 100, lamp at maximum brightness. One can define how much time the lamp stays at maximum brightness, when creating the lamp object, passing this time to the constructor through parameter, \textit{timeoutSecs}, in seconds, being defined into \textit{LampOnTimeoutSecs}. Internally, this class uses a mutex, \textit{mutChangePWM} to protect the PWM value when using \textit{setBrightness} method. 

\begin{figure}[H]
	\centering
	\includegraphics[width=.5\textwidth]{09sw_specification/LS/clamp/class}
	\caption{Class Diagram: Lamp.}
	\label{fig:classlamp}
\end{figure}

%*****************************
\clearpage
\myparagraph{Class CPir}

In figure \ref{fig:classpir} is shown the PIR class. When movement is detected in the surrounding area of the lamppost, the sensor puts the high digital value in its output, triggering an interrupt service routine. When creating a object CPir, one can define the ISR to be executed, passing to the constructor a function pointer, \textit{pirISR}.

\begin{figure}[H]
	\centering
	\includegraphics[width=.5\textwidth]{09sw_specification/LS/cpir/class}
	\caption{Class Diagram: PIR.}
	\label{fig:classpir}
\end{figure}

%*****************************
\myparagraph{Class CCamera}

In figure \ref{fig:classcamera} is shown the Camera class diagram, that defines a camera object.  This class implements the control of a camera device, with filename \textit{camFilename}, thorough the basic functions \textit{open()}, \textit{close()} and \textit{capture()}, used to get an image frame from the camera.

\begin{figure}[H]
	\centering
	\includegraphics[width=.5\textwidth]{09sw_specification/LS/ccamera/class}
	\caption{Class Diagram: Camera.}
	\label{fig:classcamera}
\end{figure}

%%*****************************
%\myparagraph{Class CLDR}
%
%In figure \ref{fig:classldr} is shown the LDR class, that defines the functions to interact with the LDR sensor, using its device driver. As the ambient light is read each 10 minutes in the function \textit{LdrIsr}, one needs to define a timer to trigger this function. The last read luminance is stored in the variable \textit{oldLightCon} and is obtained using the function \textit{getLux}.
%
%\begin{figure}[H]
%	\centering
%	\includegraphics[width=.5\textwidth]{09sw_specification/classldr}
%	\caption{Class Diagram: LDR.}
%	\label{fig:classldr}
%\end{figure}
%
%%*****************************
%\clearpage
%\myparagraph{Class CFailureDetector}
%
%In figure \ref{fig:classfail} is shown the Failure Detector class. After creating an instance of this class, using the contructor \textit{FailureDetector}, the function \textit{failureDetectIsr} will be triggered each time the failure detector senses the lamp failure. 
%
%\begin{figure}[H]
%	\centering
%	\includegraphics[width=.5\textwidth]{09sw_specification/classfail}
%	\caption{Class Diagram: FailureDetector.}
%	\label{fig:classfail}
%\end{figure}

%**********************************************************
\clearpage
\subsection{Task Overview}

One can list the tasks that compose the main process:
\begin{itemize}
	\item \textbf{tParkDetection:} acquire a camera frame; processes image and search for parking spots; verify the parking spot availability;
 	\item \textbf{tSend:} sends a message to the gateway, using the LoRa module; method of \textit{CLoraComm};
	\item \textbf{tLoraRecv:} receives a message from the gateway, using the LoRa module;
	\item \textbf{tRecvSensor:} receives messages sent by the daemon, via message queue, regarding sensors information.
\end{itemize}

%**********************************************************
\subsection{Task Priority}

One needs to assign each thread a static priority level to indicate their relative urgency. Moreover, the scheduler will always pick the thread that is ready to execute with the highest priority level. Priorities must be assigned in order to ensure efficiency and execute real-time tasks.

With that in mind, the priority assignment diagram for the local system is represented in figure \ref{fig:lst_priority}.

\begin{figure}[H]
	\centering
	\includegraphics[width=.6\textwidth]{09sw_specification/LS/mainprocess_priority}
	\caption{Local System Priority Assignment Schematic.}
	\label{fig:lst_priority}
\end{figure}

%**********************************************************
\subsection{Task Synchronization}
Real-time tasks share resources and services, and as such, should be prepared to await for the availability of these resources and services, like logical resources (buffers and data), physical resources, services like directory services, etc. In order to have coordinate access to shared resources and avoid race conditions, the kernel has resources that provide synchronization tools. 

\myparagraph{Condition Variables}

A condition variable is a task synchronization tool that can be used to block (wait) one or more threads, suspending its execution. The blocked threads are awakened when the condition variable is notified. The condition variables used are listed below.

\begin{itemize}
	\item \textbf{condCamFrame:} notifies \textit{tParkDetection} to acquire a new camera frame and process it;
	\item \textbf{condSend:} used to notify \textit{tLoraSend} that a new message is ready to be sent; private member of CLoraComm class.
\end{itemize}

\myparagraph{Mutexes}

A mutex is a locking mechanism that provides mutual exclusion, supporting ownership and other protocols. A mutex is initially created in the unlocked state in which it can be acquired by a task. After being acquired, the mutex moves to the locked state. When the task releases the mutex, it returns to the unlocked state. The mutexes used are listed bellow.

\begin{itemize}
	\item \textbf{mutCamFrame:} mutex associated with the condition variable \textit{condCamFrame} to acquire a camera frame;
		
	\item \textbf{mutSend:} protects the message to be sent in \textit{tSend}, which can be defined in multiple places; private member of CLoraComm class;
	
	\item \textbf{mutComms:} protects LoRa communication; private member of CLoraComm class;
	
	\item \textbf{mutChangePWM:} protects the modification of PWM when defining a new PWM value for the lamp; private member of CLamp class.
	
\end{itemize}

\subsection{Task Communication}
\myparagraph{Message Queue}

A message queue is a linked list of messages stored within the kernel and identified by a message queue identifier. A message queue will be used to communicate between the main process and the \textit{dSensors}. In that way, the main process is agnostic to the cyclic reading necessary for the sensors \textit{LDR} and \textit{LampFailureDetector}, and is only informed when necessary, through the message queue.

%\myparagraph{Signals}
%
%In order to define periodic events, through a timer, it is used the signal SIGALRM. Since there are different periods to set in timers, one can list the signals used 

%**********************************************************
\subsection{Flowcharts}
%\clearpage
\myparagraph{CCommunication Methods}

\begin{figure}[H]
	\centering
	\includegraphics[width=.3\textwidth]{09sw_specification/LS/ccommunication/constructor}
	\caption{Class Diagram: CCommunication constructor.}
	\label{fig:CCommunicationConstructor}
\end{figure}

A message can be put in the waiting list to be sent through the use of \textit{push(msg)}, as shown in figure \ref{fig:CCommunicationPush}.

This function is responsible for adding a new message, \textit{msg}, to the \textit{tx\_msgs} vector, and signal the condition variable \textit{condSend}, for the thread \textit{tSend} to send the message.

\begin{figure}[H]
	\centering
	\includegraphics[width=.3\textwidth]{09sw_specification/LS/ccommunication/push}
	\caption{Class Diagram: CCommunication Push method.}
	\label{fig:CCommunicationPush}
\end{figure}

To send a message, this class has a built-in thread, \textit{tSend} that can be created using \textit{run(tprio)}, which expects a priority for the thread, \textit{tprio}, as shown in figure \ref{fig:CCommunicationinit}.

\begin{figure}[H]
	\centering
	\includegraphics[width=.25\textwidth]{09sw_specification/LS/ccommunication/init}
	\caption{Class Diagram: CCommunication Init method.}
	\label{fig:CCommunicationinit}
\end{figure}

This thread, \textit{tSend} presented in figure \ref{fig:CCommunicationtsend}, is responsible for sending queued messages to the gateway, using LoRa communication. A conditional variable is used to wake this thread when there is a new message available to be sent.

When the queue \textit{tx\_msgs} is empty, then the task goes to sleep, waiting for the condition variable \textit{condSend} to notify this task. After this, the mutex \textit{mutComms} is used to protect the communication. Then, a message is popped from the messages queue, and sent to the gateway using the method \textit{Send}, shown in figure \ref{fig:CCommunicationsend}. This continues to happen until the \textit{tx\_msgs} queue gets empty.

\begin{figure}[H]
	\centering
	\includegraphics[width=.65\textwidth]{09sw_specification/LS/ccommunication/tsend}
	\caption{Class Diagram: CCommunication tSend thread.}
	\label{fig:CCommunicationtsend}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[width=.55\textwidth]{09sw_specification/LS/ccommunication/send}
	\caption{Class Diagram: CCommunication Send method.}
	\label{fig:CCommunicationsend}
\end{figure}

There is also another method, \textit{recv()}, that receives a string, in a non blocking mode, making use of task synchronization tools to ensure that sending and receiving don't occur at the same time. This function should be used continuously if one doesn't want to miss any communication. This method is presented in figure \ref{fig:CCommunicationrecv}.

\begin{figure}[H]
	\centering
	\includegraphics[width=.5\textwidth]{09sw_specification/LS/ccommunication/recv}
	\caption{Class Diagram: CCommunication Recv method.}
	\label{fig:CCommunicationrecv}
\end{figure}

%******************************
\myparagraph{CLoraComm Methods}

An object can be created through the use of the constructor, as shown in figure \ref{fig:LoraComm}.
This starts by initializing the LoRa communication, defining the pins connected to the module and the frequency in which the device choosen previously operates, which is 433~MHz. At the end, all private members are also initialized.

\begin{figure}[H]
	\centering
	\includegraphics[width=.6\textwidth]{09sw_specification/LS/cloracomm/constructor}
	\caption{Class Diagram: CLoraComm constructor.}
	\label{fig:LoraComm}
\end{figure}

\myparagraph{tCamera}

The task tCamera is responsible for acquire a frame from the Raspberry Pi Camera and to process it. It must analyze the returned frame, in order to detect empty parking spots. This thread uses the mutex \textit{mutCamera} to protect the condition variable \textit{condCameraAcquire}, that synchronizes the camera frame acquisition with the timer that defines the camera frame acquisition period, \textit{timSampleCam}.

Firstly, this thread initializes the camera device, sets the timer \textit{timSampleCam}, locks the mutex \textit{mutCamera} and goes to sleep mode, waiting for the conditon variable \textit{condCameraAcquire} to be signaled. This happens when a \textit{timSampleCam} period has elapsed and the thread wakes up. Now, one can capture a camera frame in order to process it, unlocking the mutex \textit{mutCamera}. A timer, \textit{timCamMax}, is setted to report the error if the image is taking too much time to being processed.

In the image processing part of the thread, if there aren't parking spots coordinates stored, then it is necessary to search for parking spots. After that, one can detect cars using the pre-trained model and the function \textit{detectCars} that detects cars in the image. If the coordinates of a detected car matches the coordinates of the parking spot, then one can assume that the parking spot is occupied. If the parking spot status has changed, then it is necessary to send this to the remote system, using the LoRa communication module. In figure \ref{fig:flow_tcamera}, is shown the thread \textit{tCamera} flowchart.

\begin{figure}[H]
	\centering			
%	\includegraphics[width=1\textwidth]{09sw_specification/clocalsystem/tparkdetection}
	\caption{Main Process Flowchart: tCamera.}
	\label{fig:flow_tcamera}
\end{figure}

\myparagraph{searchParkingSpots}

This function, represented in figure \ref{fig:search}, is used to process the image captured by the camera and detect parking spots. This is done using the algorithm defined previously in the section \ref{section:imageProc}, and starts by converting the frame to a grey scale image, apply the canny edge filter to highlight the edges of the image captured. After having the edges, one can select only the vertical and horizontal straight lines and intersect them, storing the intersection points, that are the parking spot coordinates.

\begin{figure}[H]
	\centering			
%	\includegraphics[width=.5\textwidth]{09sw_specification/cparkdetection/getoutline}
	\caption{Function to process image and detect parking spots.}
	\label{fig:search}
\end{figure}


\myparagraph{tRecvSensors}

This task, presented in figure \ref{fig:flow_trecv_sensors}, is responsible for receiving messages sent by the sensors daemon, through a message queue.

When the message queue is not empty, this task reads a message from the message queue and parses it, in order to find out which sensor was triggered and what action this system should take. For that, a list of commands may be defined:
\begin{itemize}
%	\item Lamp Max: the lamp brightness must be at its maximum (PWM=100);
	\item Lamp Min: the lamp must be at minimum bright level (PWM = \textit{MIN\_BRIGHT\_PWM});
	\item Lamp OFF: the lamp must be OFF (PWM=0);
	\item Lamp Fail: the lamp must be OFF, since there was a failure detected on the lamp.
\end{itemize}

\begin{figure}[H]
	\centering
%	\includegraphics[width=.4\textwidth]{09sw_specification/clocalsystem/trecvsensors}
	\caption{Main Process Flowchart: tRecvSensors.}
	\label{fig:flow_trecv_sensors}
\end{figure}

%**********************************************************
\clearpage
%\myparagraph{Class Lamp Constructor and Destroyer}
%
%This functions, presented in figure \ref{fig:flow_lampconstruct}, are responsible for initializing and destroying a Lamp object. First, in the constructor, which is the left side function, the PWM peripheral is initialized, then the mutex that is used to protect the change of PWM is also initialized. On the destroyer side, the opposite is done, by the terminating the PWM generation.
%
%\begin{figure}[H]
%	\centering	
%	\includegraphics[width=.7\textwidth]{09sw_specification/lampconstruct}
%	\caption{Class Lamp Flowchart: Constructor and Destroyer.}
%	\label{fig:flow_lampconstruct}
%\end{figure}

\myparagraph{setBrightness}

This function, presented in figure \ref{fig:flow_setbrightness}, is responsible for changing the PWM associated with the lamp, which is directly related to its brightness. Through \textit{setPWM(lux)} one can change the current lamp PWM to \textit{lux} value, being this an integer between 0 to 100. When the PWM is maximum, a timer is started that defines how much time the lamp is ON, \textit{LAMP\_ON\_TIMEOUT} in seconds, if there isn't another call of this function.

\begin{figure}[H]
	\centering	
%	\includegraphics[width=.6\textwidth]{09sw_specification/clamp/setbrightness}
	\caption{Class Lamp Flowchart: setBrightness.}
	\label{fig:flow_setbrightness}
\end{figure}


%**********************************************************
\clearpage
\myparagraph{tLoraRecv}

This task is responsible for receiving messages from the gateway, using LoRa communication.

When a message is received, using \textit{LoraComm.recv()}, this is parsed and later, the respective command will be executed.

The flowchart for this task is presented in figure \ref{fig:LStLoraRecv}

\begin{figure}[H]
%	\centering		\includegraphics[width=.55\textwidth]{09sw_specification/clocalsystem/tlorarecv}
	\caption{Class Communication Flowchart: tLoraRecv.}
	\label{fig:LStLoraRecv}
\end{figure}

% FLOWCHARTS SENSORS

\myparagraph{PirIsr}
The PIR sensor uses the GPIO of the Raspberry Pi in order to inform the system if there's movement in the surrounding area. In the afirmative case, it puts the high digital value on its output, and this can be used to generate an interrupt service routine, triggered on the rising edge of the output signal of the sensor. When this routine is executed, it locks the mutex \textit{mutChangePWM} and assign the \textit{PWM\_val} its maximum value, 100 \%, unlocking the mutex. Now, one needs to send the PWM value to the remote system through the LoRa communications, in order to be updated in the remote system. In the figure \ref{fig:pir_isr}, is represented the flowchart of the PirIsr function.

\begin{figure}[H]
	\centering
%	\includegraphics[width=.4\textwidth]{09sw_specification/clocalsystem/pirisr}
	\caption{PirIsr flowchart.}
	\label{fig:pir_isr}
\end{figure}

\myparagraph{LdrIsr}
The ambient light sensor, LDR, is used to determine when is time to turn on the lights, that is, when is night time and interfaces with the Raspberry Pi through I2C protocol communication. As the sun set or the sun rise is a relatively long time process, there's no need to keep checking the sensor output value all the time, so one can define a period to get the sensor value, \textit{LDR\_TIM}, that can be 10 minutes. In figure \ref{fig:ldr_isr} is shown the LDR sensor interrupt service routine, triggered by the timer overflow. When the timer period elapses, the illuminance value is calculated by the sensor. If this value is lower than the threshold value defined as good luminosity illuminance, GOOD\_LIGHT\_LUX, then the auxiliary variable, \textit{lightCon} is setted to high. In the next step, if the \textit{oldLightCon} variable (stores the last ambient light condition) is not equal to the auxiliary variable, then it is needed to change the \textit{oldLightCon} variable and send message to the process that controls the lamp PWM, through message queue. 

\begin{figure}[H]
	\centering
%	\includegraphics[width=.7\textwidth]{09sw_specification/ldr_isr}
	\caption{LdrIsr flowchart.}
	\label{fig:ldr_isr}
\end{figure}

\myparagraph{FailureDetectIsr}
In figure \ref{fig:fail_isr} is represented the FailureDetectIsr flowchart. Similarly to the PIR sensor, this routine is triggered on the rising edge of the output signal of the sensor. When the Failure detector detects that the lamp is broken, it puts the high digital value in its output, triggering this function. In this routine, the PWM is setted to 0 \% and are sent two messages through message queue: one to inform the process, that controls the lamp, to change the PWM value in the channel; and the other to notify the remote system that the lamp is broken, in order to update this status on the database.

\begin{figure}[H]
	\centering
%	\includegraphics[width=.5\textwidth]{09sw_specification/fail_isr}
	\caption{FailureDetectIsr flowchart.}
	\label{fig:fail_isr}
\end{figure}

%**********************************************************
\subsection{Start-up Process}
In figure \ref{fig:bootLS} is shown the start-up process for the local system. When booting up, the local system creates all necessary objects, as presented previously, and initializes them, as well as threads \textit{tLoraRecv} and \textit{tRecvSensors}.

\begin{figure}[H]
	\centering
%	\includegraphics[width=0.30\textwidth]{09sw_specification/bootLS}
	\caption{Start-Up Process: Local System.}
	\label{fig:bootLS}
\end{figure}

%%**********************************************************
%\subsection{Shutdown Process}

%**********************************************************
\clearpage
\subsection{Device Driver}
In this project it will be implemented a device driver for a GPIO pin, used to read from the sensors PIR and LampFailureDetector.

First, one has to see what are registers that the board uses, relating to GPIO pins. In the Raspberry Pi 4B documentation, \cite{rpi_datasheet}, one finds the registers easily for the GPIO pins that needs to be used for implementing the interface. The BCM2711 chip has 58 GPIO lines, split into three banks. Bank 0 is the one mapped on the header pins, from GPIO 0 to GPIO 27. Also, the GPIO registers base address is the 0x7E200000 and the address used is 32-bits.

To configure a pin as output or input, or to set or reset its value, the registers presented in table \ref{table:gpio_reg} are used.

\begin{table}[H]
	\centering
	\resizebox{\columnwidth}{!}
	{
		\begin{tabular}{|m{2,5cm}|m{2,7cm}|m{6,8cm}|m{1,6cm}|}
			\hline
			\textbf{Address} & \textbf{Field Name} & \textbf{Description} & \textbf{R/W}
			\\\hline\hline
			0x7E200000 & GPFSEL0 & GPIO Function Select 0 (GPIO 0-9) &  R/W
			\\\hline
			
			0x7E200004 & GPFSEL1 & GPIO Function Select 1 (GPIO 10-19) & R/W
			\\\hline
			
			0x7E200008 & GPFSEL2 & GPIO Function Select 2 (GPIO 20-29) & R/W
			\\\hline
			
			0x7E20000C & GPFSEL3 & GPIO Function Select 3 (GPIO 30-39) & R/W
			\\\hline
			
			0x7E200010 & GPFSEL4 & GPIO Function Select 4 (GPIO 40-49) & R/W
			\\\hline
			
			0x7E200014 & GPFSEL5 & GPIO Function Select 5 (GPIO 50-53) & R/W
			\\\hline
			
			0x7E200018 & - & Reserved - & -
			\\\hline
			
			0x7E20001C & GPSET0 & GPIO Pin Output Set 0 (0-31) & W
			\\\hline
			
			0x7E200020 & GPSET1 & GPIO Pin Output Set 1 (32-53) & W
			\\\hline
			
			0x7E200024 & - & Reserved - & -
			\\\hline
			
			0x7E200028 & GPCLR0 & GPIO Pin Output Clear 0 (0-31) & W
			\\\hline
			
			0x7E20002C & GPCLR1 & GPIO Pin Output Clear 1 (32-53) & W
			\\\hline			
		\end{tabular}
	}
	\caption{Raspberry Pi Registers used for GPIO configuration.}
	\label{table:gpio_reg}
\end{table}

The \textit{GPFSELx} register is used to define the operation of the GPIO pins, input or output. The \textit{GPFSETx} / \textit{GPFCLRx} are registers used to set or clear pins, respectively. Each register \textit{GPFSELx} contains 10 GPIOs.

As defined in the Hardware Specification section, PIR sensor will have its output connected to the pin 27 of the Raspberry Pi, as the Lamp Failure Detector will have its output connected to the pin 22. Therefore, the register to define both pins as input is \textit{GPFSEL2}.
