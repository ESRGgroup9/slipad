%**********************************************************
\section{Tools Setup}
\input{./texts/implementation/toolssetup}

%**********************************************************
\clearpage
\section{System Configuration}
\input{./texts/implementation/sysconfig}

%**********************************************************
\clearpage
\section{Image Generation}
\input{./texts/implementation/imagegen}

%**********************************************************
%\clearpage
\section{System Initialization}
\input{./texts/implementation/sysinit}

%**********************************************************
\clearpage
\section{Device Drivers}
\input{./texts/implementation/ddrivers}

%**********************************************************
\clearpage
\section{LoRa communication}
LoRa communication was implemented by deriving a third-party software from Arduino. \cite{sx1278_lib} Using \verb|bcm2835| C library one was able to control all the needed GPIO and SPI functions. \cite{bcm2835} \cite{bcmspi}

By reading the LoRa module SX1278 documentation \cite{sx1278}, (page 80) one is able to find the figure \ref{fig:sx1278_spi}. The SPI interface gives access to the configuration register via a synchronous full-duplex protocol. One of three access modes to the registers is used - SINGLE access. In this mode:
\begin{itemize}
	\item \textbf{Write access:} an address byte followed by a data byte is sent;
	\item \textbf{Read access:} an address byte is sent and a read byte is received;
\end{itemize}

\begin{figure}[H]
	\centering	
	\includegraphics[width=1\textwidth]{12implementation/sx1278_spi}
	\caption{SPI Timing Diagram (single access).}
	\label{fig:sx1278_spi}
\end{figure}

A transfer is always started by the NSS pin going low. MISO is high impedance when NSS is high. MOSI is generated by the master on the falling edge of SCK and is sampled by the slave on the rising edge of SCK. MISO is generated by the slave on the falling edge of SCK. Both data to be transmitted and that has been received are stored in a configurable \ac{fifo} device. It is accessed via the SPI interface and provides several interrupts for transfer management. (Page 66, \cite{sx1278})
\\
In listing \ref{lst:lorasingletx} one can see LoRa single transfer function, which sends two bytes to the slave. 

\clearpage
\begin{lstlisting}[caption={LoRa single transfer.}, label={lst:lorasingletx}]
// set NSS pin low. Begin transfer
digitalWrite(_ss, LOW);

bcm2835_spi_transfer(address);
response = bcm2835_spi_transfer(value);

// set NSS pin high. Stop transfer
digitalWrite(_ss, HIGH);
\end{lstlisting}

By default, the device is configured at power up so that half of the available memory is dedicated to receive
(\verb|RegFifoRxBaseAddr| initialized at address 0x00) and the other half is dedicated for  (\verb|RegFifoTxBaseAddr| initialized at address 0x80). Therefore, when one wants to perform a transmit to the device, the address is always above \verb|0x80|. On the other hand, when one wants to perform a reading, the address is bellow \verb|0x80|. With that in mind one can use bit-masking to define the address for the operation, where, \verb|reg_addr| is the SX1278 register one wants to access:

\begin{itemize}
	\item \textbf{Read:} \verb|address = reg_addr & 0x7f| and \verb|value = 0x00|. The \verb|response| variable is the response from the slave;
	
	\item \textbf{Write:} \verb+address = reg_addr | 0x80+ and \verb|value| is the value to be written to the given address. \verb|response| is not used.
\end{itemize}

A LoRa message is defined by the class \verb|LoRaMsg| having the attributes shown in listing \ref{lst:loramsg}.

\begin{lstlisting}[caption={LoRa message.}, label={lst:loramsg}]
int recvAddr;     	// receiver address
int sendAddr;     	// sender address

int msgID;        	// message ID
size_t msgLength; 	// message length
string msg;       	// message
\end{lstlisting}

In listing \ref{lst:lorasend} is shown the main core of LoRa send function. This sends a series of attributes in each message, regarding destination address, sender address, message ID, message length and the message itself.

\begin{lstlisting}[caption={LoRa send function.}, label={lst:lorasend}]
beginPacket();

// add destination address  
write(destination);
// add sender address
write(localAddress);
// add message ID
write(msgCount);
// add message length
write(msg.length());
// add message
write(msg);

endPacket();
\end{lstlisting}

The function which implements LoRa receive, receives all of the attributes sent in the function above. Also it does some additional verifications to ensure communication integrity. The destination address in the message is compared to the local address of the device receiving the message, in order to avoid messages being mistakenly read. Besides that, one checks if the received message length matches the supposed length, by comparing the received message length to the message field regarding the message length.

In order to define LoRa status before a send/receive operation, a class is defined, as presented in listing \ref{lst:loraerr}.
 
\begin{lstlisting}[caption={LoRaError enum class.}, label={lst:loraerr}]
enum class LoRaError
{
	MSGOK = 0,  	// Message OK
	ENOMSGR,    	// No message received
	ENOTME,     	// Message received is not for this device
	EBADLMSG    	// Message received lengths does not match
};
\end{lstlisting}

%**********************************************************
\clearpage
\section{PWM control}
In order to control the lamp, a PWM signal is used. For that, one can use \verb|bcm2835| library to control a PWM channel, producing the desired PWM signal at the selected GPIO pin. \cite{bcmpwm}

