%**********************************************************
\section{Tools Setup}
\input{./texts/implementation/toolssetup}

%**********************************************************
\clearpage
\section{System Configuration}
\input{./texts/implementation/sysconfig}

%**********************************************************
\clearpage
\section{Image Generation}
\input{./texts/implementation/imagegen}

%**********************************************************
%\clearpage
\section{System Initialization}
\input{./texts/implementation/sysinit}

%**********************************************************
\clearpage
\section{Device Drivers}
\input{./texts/implementation/ddrivers}

%**********************************************************
\clearpage
\section{LoRa communication}
LoRa communication was implemented by deriving a third-party software from Arduino. \cite{sx1278_lib} Using \verb|bcm2835| C library one was able to control all the needed GPIO and SPI functions. \cite{bcm2835}

By reading the LoRa module SX1278 documentation \cite{sx1278}, one is able to find the figure \ref{fig:sx1278_spi}. The SPI interface gives access to the configuration register via a synchronous full-duplex protocol. One of three access modes to the registers is used - SINGLE access. In this mode:
\begin{itemize}
	\item \textbf{Write access:} an address byte followed by a data byte is sent;
	\item \textbf{Read access:} an address byte is sent and a read byte is received;
\end{itemize}

\begin{figure}[H]
	\centering	
	\includegraphics[width=1\textwidth]{12implementation/sx1278_spi}
	\caption{SPI Timing Diagram (single access).}
	\label{fig:sx1278_spi}
\end{figure}

A transfer is always started by the NSS pin going low. MISO is high impedance when NSS is high. MOSI is generated by the master on the falling edge of SCK and is sampled by the slave on the rising edge of SCK. MISO is generated by the slave on the falling edge of SCK.

A LoRa message is defined by the class \verb|LoRaMsg| having the attributes shown in listing \ref{lst:loramsg}.

\begin{lstlisting}[caption={LoRa message}, label={lst:loramsg}]
int recvAddr;     	// receiver address
int sendAddr;     	// sender address

int msgID;        	// message ID
size_t msgLength; 	// message length
string msg;       	// message
\end{lstlisting}

In listing \ref{lst:lorasend} is shown the main core of LoRa send function. This sends a series of attributes in each message, regarding destination address, sender address, message ID, message length and the message itself.

\begin{lstlisting}[caption={LoRa send function}, label={lst:lorasend}]
beginPacket();

// add destination address  
write(destination);
// add sender address
write(localAddress);
// add message ID
write(msgCount);
// add message length
write(msg.length());
// add message
write(msg);

endPacket();
\end{lstlisting}

The function which implements LoRa receive, receives all of the attributes sent in the function above. Also it does some additional verifications to ensure communication integrity. The destination address in the message is compared to the local address of the device receiving the message, in order to avoid messages being mistakenly read. Besides that, one checks if the received message length matches the supposed length, by comparing the received message length to the message field regarding the message length.

In order to define LoRa status before a send/receive operation, a class is defined, as presented in listing \ref{lst:loraerr}.
 
\begin{lstlisting}[caption={LoRaError}, label={lst:loraerr}]
enum class LoRaError
{
	MSGOK = 0,  	// Message OK
	ENOMSGR,    	// No message received
	ENOTME,     	// Message received is not for this device
	EBADLMSG    	// Message received lengths does not match
};
\end{lstlisting}