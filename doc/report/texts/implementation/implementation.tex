%**********************************************************
\section{Tools Setup}
\input{./texts/implementation/toolssetup}

%**********************************************************
\clearpage
\section{System Configuration}
\input{./texts/implementation/sysconfig}

%**********************************************************
\clearpage
\section{Image Generation}
\input{./texts/implementation/imagegen}

%**********************************************************
%\clearpage
\section{System Initialization}
\input{./texts/implementation/sysinit}

%**********************************************************
\clearpage
\section{Device Drivers}
\input{./texts/implementation/ddrivers}

%**********************************************************
\clearpage
\section{LoRa communication}
LoRa communication was implemented by deriving a third-party software from Arduino. \cite{sx1278_lib} Using \verb|bcm2835| C library one was able to control all the needed GPIO and SPI functions. \cite{bcm2835} \cite{bcmspi}

By reading the LoRa module SX1278 documentation \cite{sx1278}, (page 80) one is able to find the figure \ref{fig:sx1278_spi}. The SPI interface gives access to the configuration register via a synchronous full-duplex protocol. One of three access modes to the registers is used - SINGLE access. In this mode:
\begin{itemize}
	\item \textbf{Write access:} an address byte followed by a data byte is sent;
	\item \textbf{Read access:} an address byte is sent and a read byte is received;
\end{itemize}

\begin{figure}[H]
	\centering	
	\includegraphics[width=1\textwidth]{12implementation/sx1278_spi}
	\caption{SPI Timing Diagram (single access).}
	\label{fig:sx1278_spi}
\end{figure}

A transfer is always started by the NSS pin going low. MISO is high impedance when NSS is high. MOSI is generated by the master on the falling edge of SCK and is sampled by the slave on the rising edge of SCK. MISO is generated by the slave on the falling edge of SCK. Both data to be transmitted and that has been received are stored in a configurable \ac{fifo} device. It is accessed via the SPI interface and provides several interrupts for transfer management. (Page 66, \cite{sx1278})
\\
In listing \ref{lst:lorasingletx} one can see LoRa single transfer function, which sends two bytes to the slave. 

\clearpage
\begin{lstlisting}[caption={LoRa single transfer.}, label={lst:lorasingletx}]
// set NSS pin low. Begin transfer
digitalWrite(_ss, LOW);

bcm2835_spi_transfer(address);
response = bcm2835_spi_transfer(value);

// set NSS pin high. Stop transfer
digitalWrite(_ss, HIGH);
\end{lstlisting}

By default, the device is configured at power up so that half of the available memory is dedicated to receive
(\verb|RegFifoRxBaseAddr| initialized at address 0x00) and the other half is dedicated for  (\verb|RegFifoTxBaseAddr| initialized at address 0x80). Therefore, when one wants to perform a transmit to the device, the address is always above \verb|0x80|. On the other hand, when one wants to perform a reading, the address is bellow \verb|0x80|. With that in mind one can use bit-masking to define the address for the operation, where, \verb|reg_addr| is the SX1278 register one wants to access:

\begin{itemize}
	\item \textbf{Read:} \verb|address = reg_addr & 0x7f| and \verb|value = 0x00|. The \verb|response| variable is the response from the slave;
	
	\item \textbf{Write:} \verb+address = reg_addr | 0x80+ and \verb|value| is the value to be written to the given address. \verb|response| is not used.
\end{itemize}

A LoRa message is defined by the class \verb|LoRaMsg| having the attributes shown in listing \ref{lst:loramsg}.

\begin{lstlisting}[caption={LoRa message.}, label={lst:loramsg}]
int recvAddr;     	// receiver address
int sendAddr;     	// sender address

int msgID;        	// message ID
size_t msgLength; 	// message length
string msg;       	// message
\end{lstlisting}

In listing \ref{lst:lorasend} is shown the main core of LoRa send function. This sends a series of attributes in each message, regarding destination address, sender address, message ID, message length and the message itself.

\begin{lstlisting}[caption={LoRa send function.}, label={lst:lorasend}]
beginPacket();

// add destination address  
write(destination);
// add sender address
write(localAddress);
// add message ID
write(msgCount);
// add message length
write(msg.length());
// add message
write(msg);

endPacket();
\end{lstlisting}

The function which implements LoRa receive, receives all of the attributes sent in the function above. Also it does some additional verifications to ensure communication integrity. The destination address in the message is compared to the local address of the device receiving the message, in order to avoid messages being mistakenly read. Besides that, one checks if the received message length matches the supposed length, by comparing the received message length to the message field regarding the message length.

In order to define LoRa status before a send/receive operation, a class is defined, as presented in listing \ref{lst:loraerr}.
 
\begin{lstlisting}[caption={LoRaError enum class.}, label={lst:loraerr}]
enum class LoRaError
{
	MSGOK = 0,  	// Message OK
	ENOMSGR,    	// No message received
	ENOTME,     	// Message received is not for this device
	EBADLMSG    	// Message received lengths does not match
};
\end{lstlisting}

%**********************************************************
\clearpage
\section{PWM control}
In order to control the lamp, a PWM signal is used. For that, one can use \verb|bcm2835| library to control a PWM channel, producing the desired PWM signal at the selected GPIO pin. \cite{bcmpwm}

Considering that the clock which drives the PWM channels, \verb|clock|, is 54 MHz, and the lamp will operate at 50 Hz, \verb|freq|.

\[ RANGE = \frac{clock}{clock_{div} * freq} \]

Using a clock divider of 16, $clock_{div}$, one gets \verb|RANGE = 67500|. The variable \verb|RANGE| defines the maximum range of the PWM output, as shown in listing \ref{lst:pwmconfig}. One used \verb|PWM_CHANNEL 0|.

\begin{lstlisting}[caption={PWM configuration.}, label={lst:pwmconfig}]
// Set the output pin to Alt Fun 5, to allow PWM channel 0 to be output there
bcm2835_gpio_fsel(PWM_PIN, BCM2835_GPIO_FSEL_ALT5);
// set clock divider
bcm2835_pwm_set_clock(BCM2835_PWM_CLOCK_DIVIDER_16);
//CTL reg
bcm2835_pwm_set_mode(PWM_CHANNEL, 1, 1);
//RNG1/2 reg
bcm2835_pwm_set_range(PWM_CHANNEL, RANGE);
\end{lstlisting}

One can set the PWM pulse ratio to emit to \verb|RANGE|, where the duty cycle, \verb|duty| a value from 0 to 1, controls the PWM output ratio as a fraction of the range as shown in listing \ref{lst:pwmset}.

\begin{lstlisting}[caption={PWM set duty cycle.}, label={lst:pwmset}]
bcm2835_pwm_set_data(PWM_CHANNEL, (duty*RANGE));
\end{lstlisting}

\clearpage
\section{Luminosity Sensor}
\label{section:lumSensor}
As specified before, in order to know when to turn on/ off the lamp, it is used a luminosity sensor, the TSL2581. This module uses the I2C communication protocol to interface with the Raspberry Pi, being implemented based on a third-party software \cite{tsl2581_code}. As for the LoRa communication, one used the bcm2835 C library to communicate with the sensor module by I2C. \cite{bcmpiic}

From the theoretical foundations, one knows that the TSL2581 module uses a data line, SDA, to send and receive data, and a clock signal line, SCL, to synchronize the communication with the master device.

The sensor datasheet \cite{TSL2581_DS} shows that for the command code byte is used the \textit{Command Register} of the TSL2581, that is composed by:

\begin{itemize}
	\item \textit{CMD} bit: set to '1' when one wants to select the \textit{COMMAND} register;
	\item \textit{TRANSACTION} two bits: selects type of transaction to follow in subsequent data transfers, read/ write (R/W) mode and the special function register. For '00', select the I2C writing mode. For '10', selects the I2C reading mode which supports the read block protocol. For 11, select the special function register. 
	\item \textit{ADDRESS} five bits: when the \textit{TRANSACTION} field selects the R/W mode, then this field selects the bus address of the slave; when the \textit{TRANSACTION} field is set to '11', this field specifies a special command function.
\end{itemize}	

\myparagraph{I2C Address}

This module has three 7-bit address, as shown in table \ref{table:tsl_address}, and one can select one of them. By default, the \textit{ADDR state} register is set to FLOAT, so this device address in the I2C bus is the 0x39.

\begin{table}[H]
	\centering
	\begin{tabular}{|m{3cm}|m{3cm}|}
		\hline
		\textbf{ADDR State} & \textbf{Address}
		\\\hline\hline
		VCC & 0x49
		\\\hline
		FLOAT & 0x39
		\\\hline
		GND & 0x29
		\\\hline
	\end{tabular}
	
	\caption{TSL2581 I2C addresses.}
	\label{table:tsl_address}
\end{table}

\myparagraph{TSL2581 Initialization}

After connecting the device in the I2C bus, one should configure its registers before reading the value from its two ADC channels. In the listing \ref{lst:tslConfig} is shown the TSL2581 device initialization. First, one needs to configure the I2C bus, using the \verb|DEV_ModuleInit| function, passing, by argument, the device address of the light sensor, \verb|ADDR_FLOAT| (0x39, default). Using the \verb|CONTROL| register, one can power on the device, that puts all registers to their default value, enabling the R/W transactions. As the day-night transition is slow, one does not need to read the luminosity value much frequently, so one can define the maximum integration time (688,5 ms). It is also important to define the gain of the sensor. This sensor supports gains of 1, 8, 16 or 111. For indoor tests, it was used a gain of 16, but in a real outdoor model, it must be used a gain of 1.

\begin{lstlisting}[caption={TSL2581 Initialization.}, label={lst:tslConfig}]
if(DEV_ModuleInit(ADDR_FLOAT)==1)
	return false;

IIC_Write(COMMAND_CMD | CONTROL,CONTROL_POWERON);	// power on

IIC_Write(COMMAND_CMD | TIMING, INTEGRATIONTIME_688MS);  	// 688,5 ms
IIC_Write(COMMAND_CMD | CONTROL, ADC_EN | CONTROL_POWERON); // Every ADC cycle generates interrupt
IIC_Write(COMMAND_CMD | INTERRUPT, INTR_INTER_MODE);		// TEST MODE
IIC_Write(COMMAND_CMD | ANALOG, GAIN_16X);					// GAIN = 16
\end{lstlisting}

\myparagraph{Read Luminosity Values}

When the device is configured, one can read the luminosity values of the module channels. The TSL2581 has two channels: 

\begin{itemize}
	\item Channel 0: Value of visible and infrared light;
	\item Channel 1: Value of infrared light.
\end{itemize}

The listing \ref{lst:tslRead} presents the code that reads the channel 0 values, as for the channel 1 values, it is the same procedure. The lower byte is read out first using the \verb|DATA0LOW| register and next the higher byte, using the \verb|DATA0HIGH| register. Then, one combine them into a 16-bit variable as seen in the line 3.

\begin{lstlisting}[caption={TSL2581 Channel 0 read.}, label={lst:tslRead}]
DataLow = IIC_Read(COMMAND_CMD | TRANSACTION | DATA0LOW); 	// read channel 0 low byte
DataHigh = IIC_Read(COMMAND_CMD | TRANSACTION | DATA0HIGH);	// read channel 0 high byte
Channel_0 = 256 * DataHigh + DataLow ;
\end{lstlisting}

This values should be now converted to the luminous intensity. First, one needs to scale the value using the formula presented in the listing \ref{lst:tslscale}.

\begin{lstlisting}[caption={TSL2581 Channel 0 scaling.}, label={lst:tslscale}]
// scale the channel values
channel0 = (Channel_0 * chScale0) >>  CH_SCALE;
\end{lstlisting}

After scaling, it is calculated the ratio between channel 0 and channel 1 using the formula shown in listing \ref{lst:tslscale}.

\begin{lstlisting}[caption={TSL2581 ratio calculation.}, label={lst:tslratio}]
ratio1 = (channel1 << (RATIO_SCALE + 1)) / channel0;
ratio = (ratio1 + 1) >> 1; // round the ratio value
\end{lstlisting}

After calculate the multiple of the relative channel using the formulas given in the datasheet, one can export the current luminous intensity through the code presented in listing \ref{lst:tslCalc}, where lux is the final luminosity value. 

\begin{lstlisting}[caption={TSL2581 luminosity value calculation.}, label={lst:tslCalc}]
temp = ((channel0 * b) - (channel1 * m));
temp += (1 << (LUX_SCALE - 1));			// round lsb (2^(LUX_SCALE-1))
//  temp = temp + 32768;
lux_temp = temp >> LUX_SCALE;			// strip off fractional portion
\end{lstlisting}

